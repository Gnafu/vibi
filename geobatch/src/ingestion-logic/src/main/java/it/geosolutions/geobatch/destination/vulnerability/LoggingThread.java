package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.geobatch.destination.ingestion.MetadataIngestionHandler;
import it.geosolutions.geobatch.destination.vulnerability.VulnerabilityMonitor.Message;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;

import java.io.IOException;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class LoggingThread implements Runnable {

	private boolean stopped = false;
	private int process;
	private String closePhase;
	
	VulnerabilityMonitor monitor;
	MetadataIngestionHandler metadataHandler;
	ProgressListenerForwarder listenerForwarder;
	
	private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityComputation.class);
	
	public LoggingThread(VulnerabilityMonitor monitor,
			MetadataIngestionHandler metadataHandler,
			ProgressListenerForwarder listenerForwarder, int process, String closePhase) {
		this.monitor = monitor;
		this.metadataHandler = metadataHandler;
		this.listenerForwarder = listenerForwarder;
		this.process = process;
		this.closePhase = closePhase;
	}
	
	private String getError(Throwable e) {
		Throwable t = e;
		while(t.getCause() != null) {
			t=t.getCause();
		}
		
		return t.getMessage().substring(0,Math.min(t.getMessage().length(), 1000));
	}

	@Override
	public void run() {
		while(!stopped) {
			try {
				processMessages();
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				
			}
		}
		// last round of processing before ending
		processMessages();
	}

	private void processMessages() {
		Message message = null;
		while((message = monitor.getMessageQueue().poll()) != null) {
			switch(message.getType()) {
			case ERROR:
				try {
					metadataHandler.logError(monitor.getTrace(), monitor.getErrors(), message.getContent(),
					        getError(message.getException()), 0);
				} catch (IOException e) {
					LOGGER.error("Can't update import metadata", e);
				}
				break;
			case CLOSE:
				if (process != -1 && closePhase != null) {
		            // close current process phase
		            try {
						metadataHandler.closeProcessPhase(process, closePhase);
					} catch (IOException e) {
						LOGGER.error("Can't update import metadata", e);
					}
		        }
				
				break;
			case FINISH:
				
				importFinished(monitor.getLoopCounter(), monitor.getTotal(),
						message.getContent());
				break;
			case PROGRESS:
				updateImportProgress(monitor.getLoopCounter(),
						monitor.getTotal(), 1,
						monitor.getErrors() - monitor.getStartErrors(),
						message.getContent());
			default:
				break;
			}
		}
	}
	
	private void importFinished(int count, int total, String content) {
		listenerForwarder.progressing(((float)count / (float)total) * 100.0f, content);
	}

	private void updateImportProgress(int count, int total, int batch, int errors, String message) {
		if (count % batch == 0) {
			listenerForwarder.progressing(((float)count / (float)total) * 100.0f, message);
		}
	}
	
	public void stop() {
		stopped = true;
	}

}
