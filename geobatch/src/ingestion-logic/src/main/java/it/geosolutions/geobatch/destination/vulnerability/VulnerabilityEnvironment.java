/*
 *  GeoBatch - Open Source geospatial batch processing system
 *  http://geobatch.geo-solutions.it/
 *  Copyright (C) 2013 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import it.geosolutions.geobatch.destination.common.InputObject;
import it.geosolutions.geobatch.destination.common.utils.FeatureLoaderUtils;
import it.geosolutions.geobatch.destination.ingestion.MetadataIngestionHandler;
import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;
import it.geosolutions.geobatch.destination.vulnerability.VulnerabilityMonitor.Message.TYPE;
import it.geosolutions.geobatch.flow.event.ProgressListenerForwarder;

import java.awt.image.RenderedImage;
import java.io.IOException;
import java.math.BigDecimal;
import java.util.Map;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.media.jai.JAI;

import org.geotools.data.DataStore;
import org.geotools.data.DefaultTransaction;
import org.geotools.data.FeatureStore;
import org.geotools.data.Transaction;
import org.geotools.factory.CommonFactoryFinder;
import org.geotools.filter.function.RangedClassifier;
import org.geotools.geometry.Envelope2D;
import org.geotools.jdbc.JDBCDataStore;
import org.opengis.feature.simple.SimpleFeature;
import org.opengis.feature.simple.SimpleFeatureType;
import org.opengis.filter.Filter;
import org.opengis.filter.FilterFactory2;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Utility class used for launching parallel vulnerability computations
 * 
 */
public class VulnerabilityEnvironment extends InputObject {

    /** Maximum queue dimension */
    private static final int MAXIMUM_QUEUE_SIZE = 1000000;

    /** Logger object */
    private final static Logger LOGGER = LoggerFactory.getLogger(VulnerabilityEnvironment.class);

    /** Waiting time until each idle thread is destroyed */
    private static final long TIMEOUT = 60;

    /** Latch used for handling the input threads */
   // private CountDownLatch latch;


    private AtomicBoolean threadFailure = new AtomicBoolean(false);
    
    public static String GEO_TYPE_NAME = "siig_geo_ln_arco_X";
    
    public static String PARTNER_FIELD = "fk_partner";
    
    public static FilterFactory2 filterFactory = CommonFactoryFinder.getFilterFactory2();
    
    private static Pattern TYPE_NAME_PARTS = Pattern
            .compile("^([A-Z]{2})_([A-Z]{1})_([A-Za-z]+)_([0-9]{8})(_.*?)?$");
    
    String codicePartner;
    String date;   
    int partner;

	public VulnerabilityEnvironment(String inputFeature,
			ProgressListenerForwarder listenerForwarder,
			MetadataIngestionHandler metadataHandler, DataStore dataStore) {
		super(inputFeature, listenerForwarder, metadataHandler, dataStore);
	}

	@Override
	protected boolean parseTypeName(String typeName) {
        Matcher m = TYPE_NAME_PARTS.matcher(typeName);
        if (m.matches()) {
            // partner alphanumerical abbreviation (from siig_t_partner)
            codicePartner = m.group(1);
            // partner numerical id (from siig_t_partner)
            partner = Integer.parseInt(partners.get(codicePartner).toString());
            date = m.group(4);
            return true;
        }
        return false;
    }
	
    /**
	 * 
	 * @param typeName
	 * @param aggregationLevel
	 * @return
	 */
	private String getTypeName(String typeName, int aggregationLevel) {
		return typeName.replace("X", aggregationLevel + "");
	}
	
	
    /**
     * This method calculated the vulnerability on for the levels 1 and 2.
     * 
     * The images are divided into Nx*Ny blocks and, for each block, vulnerability is calculated inside a thread.
     * 
     * @param closePhase
     * @param numXBlocks
     * @param numYBlocks
     * @param inputFeature
     * @param dataStore
     * @param metadataHandler
     * @param images
     * @param bandPerTargetNH
     * @param bandPerTargetH
     * @param writeMode
     * @param aggregationLevel
     * @param skipArcs
     * @param xStart
     * @param yStart
     * @param idStart
     * @throws Exception
     */
    public void computeLevel12(String closePhase, int numXBlocks, int numYBlocks,
            RenderedImage[] images, Map<Integer, TargetInfo> bandPerTargetNH,
            Map<Integer, TargetInfo> bandPerTargetH, String writeMode, int aggregationLevel,
            boolean skipArcs, Integer[] xStartArray, Integer[] yStartArray, Integer[] xStopArray,
            Integer[] yStopArray, String idStart, Envelope2D bbox, boolean newProcess) throws Exception {
    	
        // Optional removal of the features
        removeFeatures(metadataHandler, inputTypeName, (JDBCDataStore)dataStore, aggregationLevel, writeMode);
        
        int total = getTotal(aggregationLevel, (JDBCDataStore)dataStore, partner);
        LOGGER.info("import count: " + total);
        
        VulnerabilityMonitor monitor = new VulnerabilityMonitor();
        // take into account both human and not human
        monitor.setTotal(total * 2);
        
        int process = -1;
        int trace = -1;
        int errors = 0;

        // existing process
        if(metadataHandler != null) {
        	
        	// create or retrieve metadata for ingestion
			if(newProcess) {
				removeOldImports();
				// new process
				process = metadataHandler.createProcess();
				// write log for the imported file
				trace = metadataHandler.logFile(process, InputObject.NO_TARGET,
						partner, codicePartner, inputTypeName, date, false);
			} else {
        	
	        	MetadataIngestionHandler.Process importData = metadataHandler.getProcessData(inputTypeName);
			
		        process = importData.getId();
		        trace = (importData.getMaxTrace());
		        errors = (importData.getMaxError());
			}
        }
        if (process == -1) {
            LOGGER.error("Cannot find process for input file");
            throw new IOException("Cannot find process for input file");
        }
        monitor.setErrors(errors);
        monitor.setTrace(trace);
	    monitor.setStartErrors(errors);

		LoggingThread loggingThread = new LoggingThread(monitor,
				metadataHandler, listenerForwarder, process, closePhase);
	     
        // Max Thread Number
        int threadMaxNumber = numXBlocks * numYBlocks;
        ThreadPoolExecutor executor = new ThreadPoolExecutor(threadMaxNumber + 1, threadMaxNumber + 1,
                TIMEOUT, TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(MAXIMUM_QUEUE_SIZE));
        
        executor.execute(loggingThread);
        
        // Setting of the JAI thread number at least equal to the total thread number + 1 (if not already set)
        int parallelism = JAI.getDefaultInstance().getTileScheduler().getParallelism();
        if (parallelism < threadMaxNumber + 1) {
            JAI.getDefaultInstance().getTileScheduler().setParallelism(threadMaxNumber + 1);
        }
        
        // Set used for avoiding to calculate the same arc
        ConcurrentSkipListSet<BigDecimal> calculatedArcsIds = new ConcurrentSkipListSet<BigDecimal>();
        

        // NOT HUMAN TARGETS
        calculateFromImage(images[1], bandPerTargetNH,
				writeMode, aggregationLevel, skipArcs, xStartArray,
				yStartArray, xStopArray, yStopArray, idStart, bbox, monitor,
				executor, calculatedArcsIds, "NotHuman", threadMaxNumber, numXBlocks, numYBlocks);

        
        // HUMAN TARGETS
        // Reset of the initial set
        calculatedArcsIds.clear();
        
        
        
        calculateFromImage(images[0], bandPerTargetH,
				writeMode, aggregationLevel, skipArcs, xStartArray,
				yStartArray, xStopArray, yStopArray, idStart, bbox, monitor,
				executor, calculatedArcsIds, "Human", threadMaxNumber, numXBlocks, numYBlocks);
        
        monitor.newMessage(new VulnerabilityMonitor.Message(TYPE.FINISH, "Vulnerability calculation completed"));
        loggingThread.stop();
        // Executor termination
        executor.shutdown();

        executor.awaitTermination(TIMEOUT, TimeUnit.SECONDS);
        
        finalReport("Vulnerability computation completed", monitor.getErrors() - monitor.getStartErrors());
        
        if (process != -1 && closePhase != null) {
            // close current process phase
            if (metadataHandler != null) {
                metadataHandler.closeProcessPhase(process, closePhase);
            }
        }
        
    }

    /**
     * Calculates all the vulnerability values from a given RenderedImage.
     * The Image is a multiband, where each band represents a different target.
     * 
     * 
     * @param image
     * @param bandPerTarget
     * @param writeMode
     * @param aggregationLevel
     * @param skipArcs
     * @param xStartArray
     * @param yStartArray
     * @param xStopArray
     * @param yStopArray
     * @param idStart
     * @param bbox
     * @param monitor
     * @param executor
     * @param calculatedArcsIds
     * @param minTileX
     * @param minTileY
     * @param maxTileX
     * @param maxTileY
     * @param calcWidth
     * @param calcHeight
     * @param latch
     * @param targetID
     */
	private void calculateFromImage(RenderedImage image,
			Map<Integer, TargetInfo> bandPerTarget, String writeMode,
			int aggregationLevel, boolean skipArcs, Integer[] xStartArray,
			Integer[] yStartArray, Integer[] xStopArray, Integer[] yStopArray,
			String idStart, Envelope2D bbox, VulnerabilityMonitor monitor,
			ThreadPoolExecutor executor,
			ConcurrentSkipListSet<BigDecimal> calculatedArcsIds,
			String targetID, int threadMaxNumber, int numXBlocks, int numYBlocks) {
		
		
		// we split the tiles between numXBlocks * numYBlocks threads (e.g. 2*2 = 4 threads)
        int minTileX = image.getMinTileX();
        int minTileY = image.getMinTileY();

        int maxTileX = minTileX + image.getNumXTiles();
        int maxTileY = minTileY + image.getNumYTiles();

        int calcWidth = (int)Math.ceil((double)image.getNumXTiles() / (double)numXBlocks);
        int calcHeight = (int)Math.ceil((double)image.getNumYTiles() / (double)numYBlocks);
        
        
        // Latch initialization
        CountDownLatch latch = new CountDownLatch(threadMaxNumber);
		
        boolean arrayXPresent = xStartArray != null;
        boolean arrayYPresent = yStartArray != null;
		
        // Cycle on  Targets
        int count = 0;
		for (int x = minTileX; x < maxTileX; x += calcWidth) {
            int maxX = x + calcWidth;
            if (maxX > maxTileX) {
                maxX = maxTileX;
            }
            for (int y = minTileY; y < maxTileY; y += calcHeight) {

                int maxY = y + calcHeight;
                if (maxY > maxTileY) {
                    maxY = maxTileY;
                }
                // New vulnerability computation object used only inside this
                // thread
                VulnerabilityComputation vulnerability = new VulnerabilityComputation(inputTypeName,
                        listenerForwarder, metadataHandler, (JDBCDataStore)dataStore);
                // Checks if the arrays are present
                Integer xStart = arrayXPresent ? xStartArray[count] : null;
                Integer yStart = arrayYPresent ? yStartArray[count] : null;

                Integer xStop = arrayXPresent ? xStopArray[count] : null;
                Integer yStop = arrayYPresent ? yStopArray[count] : null;
                // Thread which executes calculations
                TileCalculator run = new TileCalculator(vulnerability, aggregationLevel, writeMode,
                        image, bandPerTarget, calculatedArcsIds, targetID, x, maxX, y, maxY,
                        skipArcs, xStart, yStart, xStop, yStop, idStart, bbox, monitor, latch);

                executor.execute(run);
                // Counter Update
                count++;
            }
        }
		try {
			latch.await();
		} catch (InterruptedException e) {
			LOGGER.error("Latch wait interrupted", e);
		}
	}

    private int getTotal(int aggregationLevel, JDBCDataStore dataStore, int partner) throws IOException {
    	Transaction transaction = new DefaultTransaction("VulnerabilityTotal");
        try {
            String geoName = getTypeName(GEO_TYPE_NAME, aggregationLevel);
            if(aggregationLevel >= 3) {
            	geoName = geoName.replace("ln", "pl");
            }
            FeatureStore<SimpleFeatureType, SimpleFeature> inputReader = FeatureLoaderUtils
					.createFeatureSource(dataStore, transaction, geoName);
            Filter partnerFilter = filterFactory.equals(filterFactory.property(PARTNER_FIELD),
                    filterFactory.literal(partner));
            return inputReader.getFeatures(partnerFilter).size();
        } finally {
        	transaction.close();
        }
	}

	/**
     * This method optionally removes the existent features in order to insert new records
     * 
     * @param metadataHandler
     * @param inputFeature
     * @param dataStore
     * @param aggregationLevel
     * @param writeMode
     * @throws IOException
     */
    private void removeFeatures(MetadataIngestionHandler metadataHandler, String inputFeature,
            JDBCDataStore dataStore, int aggregationLevel, String writeMode) throws IOException {
        // Instantiation of a new vulnerability computation
        VulnerabilityComputation vulnerability = new VulnerabilityComputation(inputFeature,
                listenerForwarder, metadataHandler, dataStore);
        vulnerability.removeFeatures(writeMode, aggregationLevel);
    }

    /**
     * This method calculated the vulnerability on for the level 3.
     * 
     * Division of the input cells into N groups, and on each group the vulnerability is calculated with a Thread
     * 
     * 
     * @param closePhase
     * @param threadMaxNumber
     * @param groups
     * @param inputFeature
     * @param dataStore
     * @param metadataHandler
     * @param images
     * @param bandPerTargetNH
     * @param bandPerTargetH
     * @param writeMode
     * @param skipArcs
     * @param xStart
     * @param yStart
     * @throws Exception
     */
    public void computeLevelGrid(int aggregationLevel, String closePhase, int threadMaxNumber, RangedClassifier groups,
            RenderedImage[] images, Map<Integer, TargetInfo> bandPerTargetNH,
            Map<Integer, TargetInfo> bandPerTargetH, String writeMode, boolean skipArcs,
            Envelope2D bbox, boolean newProcess) throws Exception {

        // Optional removal of the features associated to the
        removeFeatures(metadataHandler, inputTypeName, (JDBCDataStore)dataStore, aggregationLevel, writeMode);
        int total = getTotal(aggregationLevel, (JDBCDataStore)dataStore, partner);
        LOGGER.info("import count: " + total);
        
        VulnerabilityMonitor monitor = new VulnerabilityMonitor();
        // take into account both human and not human
        monitor.setTotal(total * 2);
        
        int process = -1;
        int trace = -1;
        int errors = 0;

        // existing process
        if(metadataHandler != null) {
        	
        	// create or retrieve metadata for ingestion
			if(newProcess) {
				removeOldImports();
				// new process
				process = metadataHandler.createProcess();
				// write log for the imported file
				trace = metadataHandler.logFile(process, InputObject.NO_TARGET,
						partner, codicePartner, inputTypeName, date, false);
			} else {
        	
	        	MetadataIngestionHandler.Process importData = metadataHandler.getProcessData(inputTypeName);
			
		        process = importData.getId();
		        trace = (importData.getMaxTrace());
		        errors = (importData.getMaxError());
			}
        }
        if (process == -1) {
            LOGGER.error("Cannot find process for input file");
            throw new IOException("Cannot find process for input file");
        }
        monitor.setErrors(errors);
        monitor.setTrace(trace);
	    monitor.setStartErrors(errors);        
        
	    LoggingThread loggingThread = new LoggingThread(monitor,
				metadataHandler, listenerForwarder, process, closePhase);
	      
        // Executor for handling N concurrent threads
        ThreadPoolExecutor executor = new ThreadPoolExecutor(threadMaxNumber + 1, threadMaxNumber + 1, 60,
                TimeUnit.SECONDS, new ArrayBlockingQueue<Runnable>(MAXIMUM_QUEUE_SIZE));

        executor.execute(loggingThread);
        
        // Setting of the JAI thread number at least equal to the total thread number + 1 (if not already set)
        int parallelism = JAI.getDefaultInstance().getTileScheduler().getParallelism();
        if (parallelism < threadMaxNumber + 1) {
            JAI.getDefaultInstance().getTileScheduler().setParallelism(threadMaxNumber + 1);
        }

        // Set used for avoiding to calculate the same cell
        ConcurrentSkipListSet<BigDecimal> calculatedArcsIds = new ConcurrentSkipListSet<BigDecimal>();

		calculateFromImageAggregate(threadMaxNumber, groups, images[1],
				bandPerTargetNH, writeMode, skipArcs, bbox, aggregationLevel,
				executor, calculatedArcsIds, "NotHuman", monitor);
        
        // HUMAN
        // Reset of the input cell Set
        calculatedArcsIds.clear();
        
        calculateFromImageAggregate(threadMaxNumber, groups, images[0],
				bandPerTargetH, writeMode, skipArcs, bbox, aggregationLevel,
				executor, calculatedArcsIds, "Human", monitor);
        
        monitor.newMessage(new VulnerabilityMonitor.Message(TYPE.FINISH, "Vulnerability calculation completed"));
        loggingThread.stop();
        // Executor termination
        executor.shutdown();

        executor.awaitTermination(TIMEOUT, TimeUnit.SECONDS);
        
        if (process != -1 && closePhase != null) {
            // close current process phase
            if (metadataHandler != null) {
                metadataHandler.closeProcessPhase(process, closePhase);
            }
        }
    }

	private void calculateFromImageAggregate(int threadMaxNumber,
			RangedClassifier groups, RenderedImage image,
			Map<Integer, TargetInfo> bandPerTarget, String writeMode,
			boolean skipArcs, Envelope2D bbox, int aggregationLevel,
			ThreadPoolExecutor executor,
			ConcurrentSkipListSet<BigDecimal> calculatedArcsIds,
			String targetID,
			VulnerabilityMonitor monitor) {
		CountDownLatch latch = new CountDownLatch(threadMaxNumber);
		long min = ((Double) groups.getMin(0)).longValue();
		long max = ((Double) groups.getMax(0)).longValue();
        // Cycle on all the Cell groups
        for (int i = 0; i < threadMaxNumber; i++) {

            VulnerabilityComputation vulnerability = new VulnerabilityComputation(inputTypeName,
                    listenerForwarder, metadataHandler, (JDBCDataStore)dataStore);
            // Setting of the Id bounds for the calculation
            vulnerability.setStartOriginId(min);
            vulnerability.setEndOriginId(max);
            
            TileCalculator run = new TileCalculator(vulnerability, aggregationLevel, writeMode, 
                    image, bandPerTarget, calculatedArcsIds, targetID, 0, 0, 0, 0, skipArcs, null, null,
                    null, null, null, bbox, monitor, latch);
            min = max + 1;
            if(i < threadMaxNumber - 1) {
            	max = ((Double) groups.getMax(i + 1)).longValue();
            }
            executor.execute(run);
        }

        try {
			latch.await();
		} catch (InterruptedException e) {
			LOGGER.error("Latch wait interrupted", e);
		}
	}

    /**
     * Inner class used for calculating vulnerability inside each separate thread
     */
    class TileCalculator implements Runnable {

        private VulnerabilityComputation vln;

        private int aggregationLevel;

        private String writeMode;

        private RenderedImage currentImage;

        private Map<Integer, TargetInfo> currentBPT;

        private ConcurrentSkipListSet<BigDecimal> keySet;

        private String targetID;

        private int minTileX;

        private int maxTileX;

        private int minTileY;

        private int maxTileY;

        private boolean skipArcs;

        private Integer xStart;

        private Integer yStart;

        private Integer xStop;

        private Integer yStop;

        private String idStart;

        private Envelope2D bbox;
        
        private VulnerabilityMonitor monitor;
        
        private CountDownLatch latch;

        /**
         * Creation of a new {@link Runnable} which calculates the vulnerability for the defined portion of the image
         * 
         * @param vln
         * @param aggregationLevel
         * @param writeMode
         * @param closePhase
         * @param currentImage
         * @param currentBPT
         * @param keySet
         * @param targetID
         * @param minTileX
         * @param maxTileX
         * @param minTileY
         * @param maxTileY
         * @param skipArcs
         * @param xStart
         * @param yStart
         * @param xStop
         * @param yStop
         * @param idStart
         * @param bbox
         */
        TileCalculator(VulnerabilityComputation vln, int aggregationLevel, String writeMode,
                RenderedImage currentImage, Map<Integer, TargetInfo> currentBPT,
                ConcurrentSkipListSet<BigDecimal> keySet, String targetID, int minTileX,
                int maxTileX, int minTileY, int maxTileY, boolean skipArcs, Integer xStart,
                Integer yStart, Integer xStop, Integer yStop, String idStart, Envelope2D bbox, 
                VulnerabilityMonitor monitor, CountDownLatch latch) {
            // Definition of all the requested variables
            this.vln = vln;
            this.aggregationLevel = aggregationLevel;
            this.writeMode = writeMode;
            this.currentImage = currentImage;
            this.currentBPT = currentBPT;
            this.keySet = keySet;
            this.targetID = targetID;
            this.minTileX = minTileX;
            this.maxTileX = maxTileX;
            this.minTileY = minTileY;
            this.maxTileY = maxTileY;
            this.skipArcs = skipArcs;
            this.xStart = xStart;
            this.yStart = yStart;
            this.xStop = xStop;
            this.yStop = yStop;
            this.idStart = idStart;
            this.bbox = bbox;
            this.monitor = monitor;
            this.latch = latch;
        }

        @Override
        public void run() {
            try {
                vln.computeVulnerability(null, aggregationLevel, writeMode, 
                        currentImage, currentBPT, targetID, minTileX, maxTileX, minTileY,
                        maxTileY, skipArcs, xStart, yStart, xStop, yStop, idStart, bbox, monitor, keySet);
            } catch (Exception e) {
                LOGGER.error("Error Calculating Vulnerability from tile (" + minTileX + ","
                        + minTileY + ") and (" + maxTileX + "," + maxTileY + ")");
                threadFailure.getAndSet(true);
            }

            latch.countDown();
        }
    }

	
}
