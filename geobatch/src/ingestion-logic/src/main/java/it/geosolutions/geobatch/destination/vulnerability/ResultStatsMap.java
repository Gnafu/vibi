/*
 *  Copyright (C) 2007-2012 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 *
 *  GPLv3 + Classpath exception
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geobatch.destination.vulnerability;

import static it.geosolutions.geobatch.destination.vulnerability.TargetPropertiesLoader.COP_SUOLO_PREFIX;
import static it.geosolutions.geobatch.destination.vulnerability.TargetPropertiesLoader.PROP_NAMESPACE_SEPARATOR;
import it.geosolutions.geobatch.destination.vulnerability.TargetManager.TargetInfo;

import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import org.apache.commons.collections.MapUtils;
import org.apache.commons.collections.SetUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * @author DamianoG
 *
 * This class store the vulnerability value for a given arc and distance.
 * For each target the result can be stored usining simply the targetId, internally the targetID will be converted into the related field name of the Vulnerability Table.   
 */
public class ResultStatsMap {
    
    private final static Logger LOGGER = LoggerFactory.getLogger(ResultStatsMap.class);
    
    /**
     * The map where the result will be stored
     */
    private Map<String, Double> statsMap;
    
    /**
     * The map that associate the pixelValue to the related zone of GroundCoverageTarget
     */
    private Map<Integer, Integer> valuesZone = new HashMap<Integer, Integer>();
    
    /**
     * The association between target IDs and vulnerability field table
     */
    private Map<Integer, String> targetMapping = new HashMap<Integer, String>();
    
    Map vulnerabilityCfg;
    
    public ResultStatsMap(Map vulnerabilityCfg){
        this.statsMap = new HashMap<String, Double>();
        this.vulnerabilityCfg = vulnerabilityCfg;
        for(Object key : vulnerabilityCfg.keySet()) {
			int targetId = (Integer)key;
			Map targetCfg = (Map)vulnerabilityCfg.get(targetId);
			if(targetCfg.containsKey("GROUPVALUE")) {
				valuesZone.put(targetId, (Integer)targetCfg.get("GROUPVALUE"));
			}
			if(targetCfg.containsKey("OUTPUTFIELD")) {
				targetMapping.put(targetId, (String)targetCfg.get("OUTPUTFIELD"));
			}
		}
    }
    
    

	public void initStatsMap(Map<Integer, TargetInfo> acceptedBands) {
		statsMap.clear();
		for(TargetInfo info : acceptedBands.values()) {
			statsMap.put(targetMapping.get(Integer.parseInt(info.getId())), 0.0d);

		}
	}



	/**
     * Add a result to the statsMap, the targetID will be converted into the field name in the Vulnerability Table.
     * 
     * @param targetID
     * @param value
     * @param forceToZero
     */
    public void addResult(String targetID, Double value, boolean forceToZero){
        if(forceToZero){
            statsMap.put(targetMapping.get(Integer.parseInt(targetID)), 0d);
        }
        else{
            statsMap.put(targetMapping.get(Integer.parseInt(targetID)), value);
        }
    }
    
    
    
    /**
     * Sum the values of otherMap into this map 
     * For ensure the correctnes of the operation use a map generated with clone method
     * 
     * @param otherMap
     */
    public void sum(ResultStatsMap otherMap){
        for(String key : otherMap.getKeySet()){
            Double statValue = (Double) otherMap.getStatsMap().get(key);
            Double d = (Double)statsMap.get(key);
            statValue += d != null ? d : 0;
            statsMap.put(key, statValue);
        }
    }
    
    /**
     * Create a new empty map with the same valuesZone and targetMapping
     */
    public ResultStatsMap clone(){
        ResultStatsMap rsm = new ResultStatsMap(vulnerabilityCfg);
        return rsm;
    }
    
    public void clear(){
        statsMap.clear();
    }
    
    public boolean isEmpty(){
        return statsMap.isEmpty();
    }
    
    public Map getStatsMap(){
        return MapUtils.unmodifiableMap(statsMap);
    }
    
    public Set<String> getKeySet(){
        return SetUtils.unmodifiableSet(statsMap.keySet());
    }
    
    private String fromPixelValueToTargetId(Integer pixelValue){
        return COP_SUOLO_PREFIX+PROP_NAMESPACE_SEPARATOR+valuesZone.get(pixelValue.intValue());
    }
}
